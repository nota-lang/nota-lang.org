%(
export let metadata = {
  title: "Nota Tutorial"
};

import {NotaCode} from "./editor";
import {nota} from "@nota-lang/nota-syntax";
import "@nota-lang/nota-components/dist/index.css";
import "../css/app.scss";
)

@ListingConfigure[language=nota()]

@Title{Nota Tutorial}

You can either edit the examples here interactively, or you can follow the instructions on the @a[href="/"]{home page} to install Nota and edit files on your own computer.

@Section{Nota syntax}

A Nota document is text mixed with commands, typically contained in a @code{.nota} file. A basic Nota document looks like this:

@NotaCode|{%(let sysname = "Nota")

@Section{#sysname: A Document Language for the Browser}

#(sysname.toUpperCase()) is my @em{favorite} way to write @a[href="https://en.wikipedia.org/wiki/Document"]{documents}!}|

%(let ExampleTable = ({examples}) => 
  @table{
    @thead{@tr{
      @th{Nota}
      @th{Translated}
    }}
    #(examples.map(([i, o]) => @tr{@td{@code{#i}} @td{@code{#o}}}))
  }
)

Nota supports three kinds of commands:

@Subsection{\@-commands}

@Definition[name="atcmd"][Label="@-command"]{
  \@-commands add document components to the output.
}
This includes HTML elements, like @code{\@em} for italics, as well as @a[href="https://reactjs.org/"]{React} components, like @code{\@Title}. Nota provides a standard library of components such as @code{\@Title}, @code{\@Section}, @code{\@Ref}, and many more. And you can also provide your own!

Here are some examples of translations between an @Ref{atcmd} and the corresponding component (in JSX syntax).

@ExampleTable[examples=[
  ["@a", "<a />"],
  ["@a{Text}", "<a>Text</a>"],
  ['@a[href="url"]{Text}', '<a href="url">Text</a>'],
  ['@(window.a)[href="url"]{Text}', '<window.a href="url">Text</window.a>']
]]   

Commands generally have three pieces: a name, code arguments, and text arguments.
  
@ul{
  @li{A name is a Javascript expression: either a plain identifier, like @code{a}, or a parenthesized expression like @code{(window.a)}.}
  @li{Code arguments use [square brackets] take Javascript code as input, for instance @code|{@a[href="url"]}|. @Ref{atcmd}s only take named code arguments, indicated by @code{href=}.}
  @li{Text arguments use {curly braces} and take text (and Nota commands) as input, such as @code{{Text}}. An @Ref{atcmd} can only take one text argument.}
}

@Subsection{\#-commands}

@Definition[name="hashcmd"][Label="#-command"]{
  \#-commands add Javascript expressions to the output. 
} 
For example, @code{\#sysname} embeds the value of the variable @code{sysname}. With parentheses, one can use any Javascript expression such as @code{\#(sysname.toUpperCase())}.

Here are some examples of translations between an @Ref{hashcmd} and the corresponding component (in Javascript syntax).

@ExampleTable[examples=[
  ["#sysname", "sysname"],
  ["#toUpperCase[sysname]", "toUpperCase(sysname)"],
  ["#toUpperCase{#sysname}", "toUpperCase([sysname])"],
  ["#(sysname.toUpperCase())", "sysname.toUpperCase()"],
  ["#charCodeAt[sysname][0]", "charCodeAt(sysname, 0)"]    
]]

If a @Ref{hashcmd} has no arguments, it is treated as a variable. If it is given arguments, then it is treated as a function call. Because Javascript only supports positional arguments, the code arguments to @Ref{hashcmd}s do not have names, and the order of arguments matters. 

Because text arguments may contain commands, they are not translated directly to strings, but rather to heterogenous arrays containing strings and document components. For instance:

@ExampleTable[examples=[
  ["Hello world.", '["Hello world."]'],
  ["Hello #sysname.", '["Hello ", sysname, "."]'],
  ["Hello @em{world}.", '["Hello ", React.createElement("em", ...["World"]), "."]']
]]

@Subsection{\%-commands}

@Definition[name="pctcmd"][Label="%-command"]{
  \%-commands add Javascript statements to the output. 
} For example, @code{\%(let sysname = "Nota")} is not inherently visible in the document, but can be used in expressions like @code{\#sysname}. @Ref{pctcmd}s take no arguments. You simply put @code|{%(...)}| and add any Javascript statement, including imports and exports.}

Statements are scoped, so variables defined are only accessible after the statement and within the current text block. For example, the command:

@Center{@code|{@span{%(let x = 1) x = #x}}|}
  
translates to (in JSX):
  
@Center{@code|{<span>{(()=>{let x = 1; return [" x = ", x]})}</span>}|}

@Section{Nota components}

The best way to understand the many Nota components is to read through an example on the @a[href="/examples.html"]{Examples page}. But we will review a few common and special ones here.

@Subsection{Document structure}

A Nota document is always contained within a @code{\@Document} component. Within a document, the main structural components are @code{\@Title}, @code{\@Section}, and @code{\@p}. A @code{\@Document} does things to help you simplify structure and reduce nesting. First, sections are automatically nested based on the order of headers. Second, paragraphs are automatically generated based on newlines. For example, this Nota input on the @Ref[Label="left"]{leftdoc} is translated to the equivalent on the @Ref[Label="right"]{rightdoc}.

@Row[style={margin: '1rem 0'}]{
  @Definition[name="leftdoc"][Tooltip=null]{@Listing|{@Document{
  @Title{My Document}  

  @Section{Introduction}

  The intro...

  @Subsection{Contributions}

  I did...

  @Section{Related work}

  It be like...
}}|}

  @div[style={width: '1rem'}]

  @Definition[name="rightdoc"][Tooltip=null]{@Listing|{@Document{
  @Title{My Document}    

  @SectionBody{
    @SectionTitle{Introduction}
    @p{The intro...}

    @SectionBody{
      @SectionTitle{Contributions}
      @p{I did...}
    }    
  }

  @SectionBody{
    @SectionTitle{Related work}
    @p{It be like...}
  }
}}|}
}

@Subsection{Definitions and references}

Nota provides @code{\@Definition} and @code{\@Ref} components for defining things and referencing them in a general way. For example:

@NotaCode|{@Definition[name="nota"][Label="Nota"]{
  Nota is a document language for the browser.
} Have you tried writing @Ref{nota}?}|

A definition has four pieces:

@ol{
  @li{@code{name}: required, string by which to reference this definition.}
  @li{@code{Label}: optional, element that is shown (by default) for a reference to this definition.}
  @li{@code{Tooltip}: optional, element to show when a reference to this definition is clicked (by default the definition's body).}
  @li{The definition body.}
}

A reference's text argument is the definition's name. You can optionally define the content of the reference:

@NotaCode|{@Definition[name="nota"]{
  Nota is a document language for the browser.
} Have you tried writing @Ref[Label=@strong{Nota}]{nota}?}|